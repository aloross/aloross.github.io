{"componentChunkName":"component---src-pages-markdown-remark-frontmatter-slug-js","path":"/blog/gestion-erreurs-node/","result":{"data":{"markdownRemark":{"html":"<h2>Jamais d'application sans ses erreurs</h2>\n<p>Des erreurs, on en voit tous les jours dans nos applications. Que celles-ci soient inattendues ou pas, elles font partie de notre quotidien et il est important de les gérer correctement afin d'éviter des incidents plus ou moins facheux.</p>\n<p>Dans le cadre d'une application NodeJS, le comportement par défaut lors d'une erreur est tout simplement le crash. Bien évidemment on utilise des outils adaptés (pm2) pour que le service soit proprement redemarré, mais laisser tomber vos utilisateurs en ligne à cause d'une erreur mineure et anticipable n'est généralement pas la meilleure chose à faire.</p>\n<p>Dans cet article, nous allons mettre en place des mécanismes afin d'assurer une gestion des erreurs basique et efficace dans nos applications NodeJS. Voici les differentes étapes de leurs mises en place :</p>\n<ul>\n<li>Distinguer les erreurs opérationnelles et les erreurs de programmation</li>\n<li>Catch les erreurs</li>\n<li>Gerer nos erreurs dans un gestionnaire centralisé</li>\n</ul>\n<p>Sans perdre plus de temps, on va mettre les mains dans le camboui et commencer à throw nos première exceptions.</p>\n<h2>Parlons des erreurs</h2>\n<p>Avant de pouvoir s'attaquer à la gestion de nos erreurs, il va être nécessaire de réflêchir un peu sur les erreurs que nous allons créer et utiliser. Pour cela, il faut en premier lieu faire la distinction entre deux types d'erreurs principales que nous allons être amener à traiter :</p>\n<ul>\n<li>\n<p>les erreurs opérationnelles anticipables et qui font partie du fonctionnement nominal de l'application (une valeur invalide dans un formulaire, un timeout sur une API externe connue pour être capricieuse, etc.) qui peuvent être remontée à l'utilisateur</p>\n</li>\n<li>\n<p>les erreurs de programmations et autres (l'indétrônable <code>undefined is not a function</code>, un problème de type quelconque, etc.) qui ne peuvent pas être anticipées et doivent mener à un redémarrage de notre appli pour éviter des comportements encore plus inattendus (//TODO petit exemple).</p>\n</li>\n</ul>\n<p>Pour résumer, les erreurs opérationnelles font partie de notre programme, les erreurs de programmation sont des bugs. Il va être de notre responsabilité de marquer la différence dans le code. Pour cela nous pouvons ajouter une propriété lorsque nous lançons une erreur opérationnelle, cela nous permettra de réagir de manière adaptée.</p>\n<p>Par exemple :</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const invalidLastnameError = new Error(&quot;Le nom est requis&quot;);\ninvalidLastnameError.isOperational = true;\nthrow invalidLastnameError;</code>\n        </deckgo-highlight-code>\n<p>Si vous voulez aller plus loin, il est également possible de créer vos propres erreurs (j'utilise la syntaxe <code>class</code> ici car c'est bien plus simple, mais il est également possible d'utiliser les prototypes)</p>\n<p>quelques exemples :</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">class APIError extends Error {\n  constructor(name, message, httpCode, isOperational = true) {\n    super(message);\n\n    this.name = name;\n    this.httpCode = httpCode;\n    this.isOperational = isOperational;\n\n    // Cette partie n&#39;est pas indispensable, mais permet d&#39;améliorer la stack trace\n    // Une petite explication par ici : https://stackoverflow.com/questions/63598211/how-to-use-error-capturestacktrace-in-node-js\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n// J&#39;utilise ici un exemple naif, dans un cadre de production, il faudrait extraire des constantes\nthrow new APIError(&quot;InvalidInput&quot;, &quot;Lastname is required&quot;, 400);</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>À noter : il est important de toujours utiliser ou étendre l'objet NodeJS <code>Error</code> natif lorsque l'on lève une exception et d'éviter d'utiliser des <code>string</code> ou encore des objets personnalisés. Cela complique la gestion des erreurs et peut amener à la perte d'information comme la stack trace.</p>\n</blockquote>\n<p>Nous avons désormais totues les cartes en mains pour lever des exceptions qui ont du sens. Elles trouveront leur place dans nos services, méthodes utilitaires, etc.\nIl va maintenant s'atteler à les catch afin de pouvoir les traiter.</p>\n<h2>Attraper les toutes</h2>\n<p>Pour gérer nos erreurs, il va falloir en premier lieu les \"catcher\". Pour cela pas de miracle, on va utiliser le bon vieux try/catch.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">try {\n  const result = function(param)\n} catch (err) {\n  // Catastrophe !\n}</code>\n        </deckgo-highlight-code>\n<p>En Javascript, l'asynchrone est partout, il va donc falloir gérer toutes nos belles fonctions qui visent le futur. pour cela, trois syntaxes (et leur méthode associée pour la gestion des erreurs) s'offrent à nous : async/await, les promises et les callbacks.</p>\n<ul>\n<li>Dans le premier cas, c'est pas sorcier, on ajoute le mot clef <code>await</code> quand il est nécessaire et le tour est joué :</li>\n</ul>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">try {\n  const result = await asyncFunctionA();\n  const result2 = await asyncFunctionB(result);\n  const result3 = await asyncFunctionC(result2);\n  await asyncFunctionD(result3);\n} catch (err) {\n  // Catastrophe !\n  handleError(err);\n}</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Pour les promises, il ne faut pas oublier le petit <code>.catch</code> :</li>\n</ul>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">asyncFunctionA()\n  .then(asyncFunctionB)\n  .then(asyncFunctionC)\n  .then(asyncFunctionD)\n  .catch(handleError);</code>\n        </deckgo-highlight-code>\n<ul>\n<li>Et finalement pour les callbacks, et bien, évitez les ! Ceux-ci sont très peu lisibles et amène au fameux <a href=\"http://callbackhell.com/\">callback hell</a>. Si vous utilisez une lib qui utilise cette option pour gérer l'asynchrone je vous conseille vivement de transformer ses méthodes en Promises à l'aide de l'helper <a href=\"https://nodejs.org/dist/latest-v8.x/docs/api/util.html#util_util_promisify_original\">promisify</a> de NodeJS ou de l'une des plétores de lib qui permettent de le faire, par exemple <a href=\"http://bluebirdjs.com/docs/api/promise.promisify.html\">bluebird</a>.</li>\n</ul>\n<p>Pour le choix entre la syntaxe async/await ou Promise, celui-ci vous appartient, je vous conseille simplement d'utiliser l'une ou l'autre et d'éviter de les mélanger afin d'harmoniser votre projet et de vous faciliter la vie.</p>\n<h2>On est pas parfait</h2>\n<p>Comme on a pu le voir, il est relativement simple d'attraper une erreur en JS, mais il est également très simple d'en oublier ! Une belle chaîne de Promise sans le catch associé et c'est la catastrophe assurée.</p>\n<p>Pour palier à tout oublie, on va utiliser 2 events disponibles dans NodeJS : <code>unhandledRejection</code> et <code>uncaughtException</code>.</p>\n<p>Un petit exemple :</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">process.on(&quot;unhandledRejection&quot;, (err) =&gt; {\n  // Une promise a été rejeteé sans être gérée dans notre code, cet event nous permet de l&#39;attraper.\n  // Nous pouvons directement la lancer sous forme d&#39;erreur, elle sera gérée par l&#39;event suivant !\n  throw err;\n});\n\nprocess.on(&quot;uncaughtException&quot;, (err) =&gt; {\n  // Ici, on reçoit les erreurs qui n&#39;ont jamais été gérées\n  handleError(err);\n});</code>\n        </deckgo-highlight-code>\n<blockquote>\n<p>Il faut garder en tête que ces events remontent des erreurs qui n'ont pas été correctement gérées en amont, il est donc très utile d'ajouter un log spécifique ou un monitring particulier dans ce cas afin de penser à corriger le problème.</p>\n</blockquote>\n<h2>Parlons des erreurs</h2>\n<p>Avant toutes choses, il va falloir faire la distinction entre deux types d'erreurs à traiter :</p>\n<ul>\n<li>\n<p>les erreurs opérationnelles anticipables et qui font partie du fonctionnement nominal de l'application (une valeur invalide dans un formulaire, un timeout sur une API externe connue pour être capricieuse, etc.) qui peuvent être remontée à l'utilisateur</p>\n</li>\n<li>\n<p>les erreurs de programmations et autres (l'indétrônable <code>undefined is not a function</code>, un problème de type quelconque, etc.) qui ne peuvent pas être anticipées et doivent mener à un redémarrage de notre appli pour éviter des comportements encore plus inattendus (//TODO petit exemple).</p>\n</li>\n</ul>\n<p>Il arrivera que certaines erreur opérationnelles améneront également à un redémarrage du service, par exemple dans le cas</p>\n<p>Pour les différencier, on peut ajouter une propriété lorsque l'on lance l'erreur, cela nous permettra de réagir de manière adaptée :</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">const invalidLastnameError = new Error(&quot;Le nom est requis&quot;);\ninvalidLastnameError.isOperational = true;\nthrow invalidLastnameError;</code>\n        </deckgo-highlight-code>\n<p>Si vous voulez aller plus loin, il est également possible de créer vos propres erreurs (j'utilise la syntaxe <code>class</code> ici car c'est bien plus simple, mais il est également possible d'utiliser les prototypes)</p>\n<p>quelques exemples :</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">class InvalidInputError extends Error {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n    this.httpCode = 400;\n    this.isOperational = true;\n  }\n}\n\nclass ResourceNotFound extends Error {\n  constructor(message) {\n    super(message);\n    this.name = this.constructor.name;\n    this.httpCode = 404;\n    this.isOperational = true;\n  }\n}\n\nthrow new InvalidInputError(&quot;Lastname is required&quot;);</code>\n        </deckgo-highlight-code>\n<h2>Et maintenant ?</h2>\n<p>Après avoir attraper toutes nos belles erreurs, il reste une dernière étape, les gérer ! Pour cela je vous conseille de créer une fonction externe qui sera responsable de les traiter.</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// Notre gestionnaire d&#39;erreur centralisé qui peut être utilisé dans tout les contextes (API, tâches CRON, etc.)\nerrorHandler.handleError = async function handleError(err) {\n  await logger.error(err)\n  await sendToMonitoringTool(err)\n\n  if (!err.isOperational) {\n    process.exit(1)\n  }\n}\n\n// Une petite fonction utilitaire pour faciliter la génération des réponses en cas d&#39;erreur\nerrorHandler.sendAPIResponse(err, res) {\n  res.status(err.httCode || 500).send(err.message)\n}</code>\n        </deckgo-highlight-code>\n<p>En application dans une application Express, ça donne ça :</p>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">// Notre service lance une erreur dans le cas ou l&#39;id est incorrect\nmovieService.get = (id) =&gt; {\n  const movie = await BD.getMovie(id);\n\n  if (!movie) {\n    throw new ResourceNotFound(&quot;This movie does not exists&quot;);\n  }\n\n  return movie;\n};\n\n// On attrape ensuite l&#39;erreur au niveau de nos routes pour les envoyer vers le middleware responsable de gérer les erreurs\n// Avec la syntaxe async/await\napp.get(&quot;/movie&quot;, function (req, res, next) {\n  try {\n    const result = movieService.get(req.id);\n    res.status(200).json(result);\n  } catch (error) {\n    next(error);\n  }\n});\n\n// Avec une promise\napp.get(&quot;/movie&quot;, function (req, res, next) {\n  movieService\n    .get(req.id)\n    .then((result) =&gt; {\n      res.status(200).json(result);\n    })\n    .catch(next);\n});\n\n// Le middleware de gestion d&#39;erreur\napp.use(function (err, req, res, next) {\n  await errorHandler.handleError(err);\n  await errorHandler.handleAPIError(err, res);\n});\n\n// Et on oublie pas les fallbacks !\nprocess.on(&quot;unhandledRejection&quot;, (reason) =&gt; {\n  throw reason;\n});\n\nprocess.on(&quot;uncaughtException&quot;, (err) =&gt; {\n  await errorHandler.handleError(err);\n});</code>\n        </deckgo-highlight-code>\n<p><a href=\"https://expressjs.com/en/guide/error-handling.html\">La doc d'Express sur le sujet</a></p>\n<blockquote>\n<p>Avec Express 5 (actuellement en alpha), les erreurs asynchrones sont automatiquement passées, il n'est donc plus nécessaire d'apeller manuellement <code>next(err)</code>. La syntaxe suivante sera suffisante :</p>\n</blockquote>\n<deckgo-highlight-code language=\"js\"  >\n          <code slot=\"code\">app.get(&quot;/movie&quot;, function (req, res, next) {\n  await movieService.get(req.id);\n});</code>\n        </deckgo-highlight-code>\n<p>Cet exemple est appliqué sur le framework Express, mais l'idée reste la même quelque soit le framwork que vous allez utiliser.</p>","frontmatter":{"date":"09/06/2021","slug":"/blog/gestion-erreurs-node","title":"La gestion des erreurs dans une application NodeJS"}}},"pageContext":{"id":"4368fa00-78d8-5991-aca2-a48d07bb3c79","frontmatter__slug":"/blog/gestion-erreurs-node","__params":{"frontmatter__slug":"blog"}}},"staticQueryHashes":[]}